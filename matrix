#!/bin/bash

#Global variable to hold file path 
datafilepath="datafile$$"
#Global variable to hold number of rows in a matrix
rows=0
#Global variable to hold the number of columns in a matrix
columns=0
#Global variable for if another function called dims
calldims="false"
#Global variable to hold filepath for the mean function
datafilepathmean="datafile$$"


function dims()
{
# Name: dims
# Arguments: Input is either a single file or stdin saved in global variable datafilepath
# Description: Calculates the number of rows and columns of the matrix
# Output: Number_of_rows Number_of_columns to stdout

# While Loop: Read each line from the datafilepath
while read myLine

do
	# increase the count for rows
	rows=$((rows+1))

	# use the first row to get the number of columns
	if [[ $rows = 1 ]]
	then
		# for each number in the row, increase the count of columns
		for i in $myLine
		do
			columns=$((columns+1))
		done
	fi

done < "$datafilepath"

# if another function did not call dims
if [ "$calldims" = "false" ]
then
# print "rows columns" to stdout 
	echo "$rows $columns" >&1
# return with 0 errors
	exit 0
fi
}

function transpose()
{
# Name: transpose
# Arguments: Input is either a single file or stdin saved in a global variable datafilepath
# Description: Takes a matrix and reflects the elements across the main diagonal (columns become rows)
# Output: Transposed matrix to stdout

# set calldims to true
calldims="true"
# call dims to get the number of columns 
dims

# set current column to 1
currentCol=1

# use a while loop to cut and paste each column into a row
while [ $currentCol -le $columns ]
do
	# cut the current column from the input and paste it into a row
	cut -f "$currentCol" "$datafilepath" | paste -s 
	# increment count of currentCol
	((currentCol++))
done

}

function mean()
{
# Name: mean
# Arguements: Input is either a single file or stdin saved in a global variable datafilepath
# Description: Takes a matrix and calculates the mean of each column
# Output: A 1xN row vector of the means of each column to stdout

# Set calldims to true
calldims="true"
# Call dims to get the number of rows which will be used to calculate mean
dims


# Call transpose function and pipe the results into the datafilepathmean file
transpose | cat > "$datafilepathmean"

# Temp file to hold the means
tempMeans="tempmeanfile"

# Read each row (column in matrix that is not transposed)
while read eachrow
do

	# for each number in the row
	for i in $eachrow
	do
	# add each number to the total of the row
		total=$((total+i))
	done
	
	# Divide the total by the number of rows
	mean=$(( (total + (rows/2)*( (total>0)*2-1 )) / rows ))
	
	# Send the mean of each column as it is found to the tempMeans file
	echo "$mean" >> "$tempMeans"

	# Reset the total and mean to 0 for the next row
	total=0
	mean=0

done < "$datafilepathmean"

# Take the results in tempMeans cut and paste them into a single line of output in stdout
cut -f1 "$tempMeans" | paste -s

# remove the temp file so it does not interfere with future runs 
rm -f "$tempMeans"

}



# Check Input before calling any function

# if the command is dims , transpose, or mean
if [ "$1" = "dims" ] || [ "$1" = "transpose" ] || [ "$1" = "mean" ]
# then check there is only up to 1 additional argument
then
	if [[ $# -gt 2 ]] || [[ $# -lt 1 ]]
	# if there is more than 1 additional argument then send error message to stderr and exit with error 1
	then
		echo "Invalid number of arguments" 1>&2
		exit 1
	
	# else if there is no additional arguments 
	elif [ $# -eq 1 ]
	# then take stdin into a new file 
	then
		cat > "$datafilepath"

	# else number of arguments is two which means a filename was provide
	else
	# so take file name and put into datafilepath variable
		datafilepath=$2
	fi

	# Check the input file is readable and exists
	if [[ -e "$datafilepath" ]] && [[ -r "$datafilepath" ]]
	# if so then call function from argument 1: 1 is dims 2 is transpose 3 is mean
	then
		$1

	# if not then send error message to stderr and exit with error 2
	else
		echo "File does not exist or cannot be read" 1>&2
		exit 2
	fi
fi
